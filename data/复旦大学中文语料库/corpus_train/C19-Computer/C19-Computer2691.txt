软件学报
JOURNAL OF SOFTWARE
1999年　第10卷　第11期　Vol.10　No.11　1999



非完全互连同构系统上的静态任务调度
章军　章立生　韩承德
　　摘要　在分布式内存多处理机DMM(distributed memory multiprocessor)系统中，不同处理机上运行的任务之间的通信开销仍然很大，有时甚至抵消了多处理机并行所带来的好处.为了使并行程序在DMM系统上能得以高效的执行，必须采用合理的调度技术将任务分配给处理机.文章首先分别给出了任务调度系统中的任务模型、处理机模型以及调度问题的形式化描述，然后在此基础上研究了任务调度中3个最重要的问题，即(1) 如何顺序选择参与调度的任务，(2) 如何选择路由，(3) 如何分配任务给处理机.其中，路由选择是按存储转发寻径与虫蚀寻径两种不同的方式来讨论的.最后，根据上述3个问题的解决策略，构造了一个非完全互连同构系统上的静态任务调度算法.
　　 关键词　静态任务调度，任务模型，处理机模型，存储转发寻径，虫蚀寻径.
　　中图法分类号　TP338
Static Task Scheduling for Incompletely Interconnected Homogeneous Systems
ZHANG Jun ZHANG Li-sheng HAN Cheng-de
(High Performance Computing Center Institute of Computing TechnologyThe Chinese Academy of Sciences Beijing 100080)
　　Abstract　 In the distributed memory multiprocessor (DMM) systems, communication overhead, involved among tasks run on different processors, is still large which even offsets the advantages brought by multiprocessor parallelism. In order to execute a parallel application efficiently, it is necessary to choose an appropriate scheduling technology to allocate processors to tasks. In this paper, formal description of general scheduling system including task model, processor model and schedule problem is presented. Three most important problems, concerning schedule in incompletely interconnected homogeneous systems, are studied, which are: (1) How to choose scheduling tasks in sequence, (2) How to choose a route, (3) How to allocate processors to tasks. In addition, the problem on how to choose a route is studied according to store-and-forward and wormhole routing respectively. In the end, a static scheduling algorithm for incompletely interconnected homogeneous systems is constructed according to the solutions to the above three problems.
　　Key words　Static task scheduling, task model, processor model, store－and－forward routing, wormhole routing.
　　在分布式内存多处理机(distributed memory multiprocesor,简称DMM)系统中，所有处理机经网络互连起来，任意两台处理机之间的通信都必须经过互连网络.近30年来，即使通信技术的发展突飞猛进，但与处理机的运算速度相比，通信开销仍然很大，是制约消息传递型系统性能进一步提高的瓶颈.
　　为了使并行程序在DMM系统上能得以高效的执行，必须采用合理的调度技术将不同的任务在适当的时刻分配给处理机去执行.对于静态任务调度而言，处理机的任务分配是在程序执行之前完成的.有关任务的计算量、任务之间的依赖关系及通信情况、每个处理机的处理能力以及它们之间的互连拓扑在编译时假定是已知的.另外，任务一旦分配给某个处理机，便只能在该处理机上执行，即任务的执行是非抢占式的(nonpreemptive).一般说来，静态调度的目标是最小化整个应用的执行时间.
　　本文考虑的问题要求处理机系统是同构的，对处理机的个数以及处理机之间是否完全互连不作限制.另外，在任务调度时，不允许任务复制.本文第1节给出了任务调度系统模型，它包含任务模型与处理机模型.第2节给出了调度问题的形式化描述.第3节讨论了非完全互连同构系统上任务调度中的3个最重要问题的解决策略,并构造了相应的调度算法，这3个问题分别是：(1) 如何顺序选择参与调度的任务，(2) 如何选择路由，(3) 如何将处理机分配给任务.其中，路由选择是按存储转发寻径与虫蚀寻径两种不同的方式来讨论的.
1　调度系统模型的形式化描述
　　调度系统模型包含任务模型与处理机模型.下面分别给出任务模型与处理机模型的形式化描述.
　　通常，任务依赖图是经程序划分后获得的，可用图理论中的有向无环图(directed acyclic graph，简称DAG)来表示，任一有向无环图(DAG)可用四元组TG=(V,E,A,D)来定义.其中:
　　(1) V=［vi］表示任务图中结点(任务图中的结点即指任务,故在本文中有时结点与任务混用)的集合，vi表示第i个任务,|V|表示图中结点数目;
　　(2) E=［ei,j］表示任务图中边(任务图中的边即指消息,故在本文中有时与消息混用)的集合，ei,j表示由vi指向vj的有向边，|E|表示图中边的数目;
　　(3) A=［ai］表示任务的计算量集合，ai表示任务vi的计算量;
　　(4) D=［di,j］表示任务之间通信的数据量集合，di,j表示任务vi发送给任务vj的数据量.
　　为了表示图TG中任务之间的互相依赖情况，下面给出两个优先(precedence)关系:及→.
　　定义1.1. 在图TG上，如果vi是vj的父结点（或vj是vi的子结点)，则有vivj；如果vi是vj的祖先结点(或vj是vi的子孙结点)，则有vi→vj.
　　由上面的定义可知，关系→具有传递性，而关系不具有传递性.ei,j∈E等价于vivj.在图1(a)中，有v3v6，v2→v8等满足上述两个关系.

(a) 有向无环图(DAG)

(b) 处理机模型

(c) 执行结果
图1 调度系统模型
　　由任务vi的父结点与祖先结点构成的集合分别记为PARENT(vi)与PRED(vi)；由任务vi的子结点与子孙结点构成的集合分别记为CHILD(vi)与SUCC(vi).在图1(a)中，PARENT(v6)=｛v1,v3｝，CHILD(v3)=｛v6,v7｝,PRED(v8)=｛v1,v2,v3,v5,v6｝，SUCC(v5)=｛v8,v9,v10｝.
　　定义1.2. 对于任务vi，若PARENT(vi)=,则vi称为入结点(entry node)；若CHILD(vi)=,则vi称为出结点(exit node).记所有的入(出)结点构成的集合为ENTRY(EXIT).
　　 这种任务执行模型又称为编译时的宏数据流模型(compile time macro data flow model)［1～3］.在该模型中，每个任务只有在它所需要的数据到齐之后，才可以开始执行，即任务的开始执行是以它所需要的数据的到齐来驱动的，任务执行完后，立即将其后代所需要的数据发送给它们.通常，数据的发送是非堵塞(nonblocking)方式的，而数据的接收是堵塞(blocking) 方式的.
　　处理机模型可以用五元组PG=(P,L,S,I,R)来描述.
　　(1) P=［pi］表示所有处理机的集合,|P|表示处理机的数目.
　　(2) L=［li,j］是一个|P|×|P|的处理机互连拓扑矩阵.li,j只能取0或1,若li,j=0，则表示pi与pj之间没有直接连接(link),若li,j=1，则表示pi与pj之间有直接连接.
　　(3) S=［si］表示处理机的运算速度集合，si表示处理机pi的运算速度.
　　(4) I=［αi］表示通信时的启动开销集合，αi表示处理机pi通信时相应的I/O处理机启动开销.
　　(5) R=［βi,j］表示两个相邻处理机之间通道的数据传输率集合，βi,j表示了两个相邻处理机pi与pj之间通道的数据传输率.
　　通常，假定所有连接都是全双工的(full duplex).每个处理单元都带有专门的硬件来支持并行通信，这样的部件称为I/O处理机，这种I/O处理机允许任务的通信与计算重叠(overlapping)地进行.
　　在同构系统(homogeneous system)上，所有处理机的运算速度相等(简记为s)，通信的启动开销相等（简记为α），并且所有通道的数据传输率都相等(简记为β)，则处理机模型可用两元组(P,L)来描述.而任务模型可以改用四元组TG=(V,E,T,D)来描述，其中V,E及D的定义同前，而T=［Γi］表示任务的计算时间集合，Γi表示执行任务vi所需要的时间，为ais.当任务vi与vj被分配到不同的处理机pm与pn上去执行时，在采用某种路由算法确定了某条路径,且路径上的所有通道均处于空闲状态时,如果采用存储转发寻径技术，任务之间的通信时间为 ci,j,m,n=pl(m,n)×(α+di,j/β),其中pl(m,n)为处理机pm与处理机pn之间路径的长度；如果采用虫蚀寻径技术，任务之间的通信时间为ci,j,m,n=α+di,j/β.
2　调度问题的形式化描述
　　任务调度的消费者是DAG图中的所有任务以及任务之间通信的消息，资源是经某种拓扑互连的处理机及处理机之间的连接.调度算法考虑的是如何将处理机分配给任务及连接分配给消息.
　　在非完全互连系统上，形式地(文献［4］也曾给出了调度问题的形式化描述,但却没有考率任务之间通信的消息),某个调度可用函数f来表示，该函数的定义域为V∪E×L，值域为P×［0,∞)∪［0,∞).对于某个任务v∈V，如果f(vi)=(pj,t)，我们称任务vi被调度到处理机pj上，并在t时刻开始执行；对于某个消息ei,j,如果f(ei,j,lm,n)=t，则表示消息ei,j在采用某种寻径策略时需要使用连接lm,n，在t时刻,该连接可以分配给该消息使用,如果消息ei,j不需要使用连接lm,n，令t=∞.
　　衡量调度性能的最主要的指标是调度长度(schedule length，许多文献［1,3］中又称为parallel time,简记为PT).调度f的调度长度PT(f)=max｛t+Γi,j｝，其中f(vi)=(pj,t)，且Γi,j=ai/sj.
　　定义2.1. 假定任务在被调度之前都映射到不同的处理机上，且这些处理机之间以完全互连的方式连接，这个假定的处理机系统又称为虚拟处理机系统.任务图TG中的静态关键路径(static critical path,简称SCP)定义为从入结点到出结点中最长的路径(包含任务之间的通信时间).
　　对于图1(a)，当α=0,β=1,s=1时,该任务图中的静态关键路径为v3v6v8v10.
　　定义2.2. 在同构系统上，在部分调度的任务图TG′中，任务图的动态关键路径(dynamic critical path,简称DCP)定义为TG′中的从入结点到出结点中最长的路径(包含任务之间的通信时间).
　　定义2.3. 在同构系统上，在部分调度的任务图TG′中，任一结点vx的top level(简记为tlevel)定义为从入结点到该结点(不包含该结点的权)的最长路径(记为tlevel(vx)).任一结点的bottom level(简记为blevel)定义为从该结点到出结点(包含该结点的权)的最长路径(记为blevel(vx)).
　　在同构系统上，在未调度的任务图TG中，SCP的长度为maxvx∈V｛tlevel(vx)+blevel(vx)｝，对于部分调度的任务图TG′，该式同样可用于计算DCP的长度.对于未调度的任务图TG，任意结点vi的tlevel与blevel的计算方法如下:

在同构系统上，若任务调度遵从拓扑顺序，已被调度结点的tlevel为该结点的开始执行时间(给出已被调度结点的tlevel值的计算,是因为计算未被调度结点的tlevel值时要用到已被调度结点的tlevel值)，未被调度结点的tlevel及blevel值的计算也采用以上两式.
3　几个关键问题的解决策略及调度算法
　　本节先给出非完全互连同构系统上静态调度中的几个关键问题的解决策略，然后给出调度算法.
　　已经发表的非完全互连同构系统上任务调度的文章极少.其中，El－Rewini在文献［5］中首先提出了非完全互连系统上任务调度的算法，但他的算法仅适用于存储转发寻径通信，而且也没有讨论如何去利用连接的最早的(这里的最早以及下面的较早都是针对处理机或连接上被占用的最后一段或下文中的第δ段时间空隙而言)空闲时间空隙(idle time slot).Kwok在文献［6］中提出了如何利用连接的最早空闲时间空隙的方法，但经过仔细分析，他的工作忽略了“不同连接上的空闲时间空隙分布是不一致的”这一实际情况.
　　非完全互连同构系统上并行任务的静态调度中要解决的问题有3个：(1) 如何顺序选择参与调度的任务，(2) 如何选择路由，(3) 如何将处理机分配给任务.
　　如何顺序选择参与调度的任务　一般认为,应优先调度关键路径上的任务.在确定关键路径时，有些算法采用静态关键路径，而有些算法采用动态关键路径.对于调度算法的性能，采用动态关键路径的算法一般优于采用静态关键路径的算法；对于调度算法的复杂度，采用动态关键路径的算法通常高于采用静态关键路径的算法.
　　如何选择路由　对于非完全互连系统，处理机之间的连接是有限的资源，在并行程序执行过程中，很有可能出现不同的消息争用同一连接的情况.因此，如果将连接也作为资源来静态地加以分配，在程序运行时，便不再需要考虑网络的链路堵塞以及死锁等问题的出现.
　　对于非完全互连同构系统，从源到目的的路径可能很多，问题是如何确定某个路由，从源发出的消息经过该路由时能尽量早地到达目的地.对于某个确定路由，如果采用某种方法能计算出消息经过该路由到达目的处理机的最早时刻，则先算出所有的路由所对应的最早时刻，便可以求出消息到达目的处理机的最早时刻并选择相应的路由.对于存储转发寻径技术，本文给出了消息经过某个路径到达目的处理机的最早时刻的计算方法；对于虫蚀寻径技术，尚没有人给出消息经过某个路径到达目的处理机的最早时刻的计算方法，本文给出了消息经过某个路径到达目的处理机的一个较早时刻的计算方法.
　　先定义两个将在下文中用到的对二元矢取分量的操作fst与scnd：
　　定义3.1. 若将操作fst与scnd作用于二元矢(x1,x2)，则fst((x1,x2))=x1，scnd((x1,x2))=x2.
　　对于任务调度f，假定任务vi已被调度，vi要向其子任务vj发送消息ei,j，如果在选择某条路径时需要使用连接lm,n.下面分两种不同的寻径方式，即存储转发寻径与虫蚀寻径来讨论如何选择路由.
　　(a) 在采用存储转发寻径技术时
　　假定在此之前已有δ个消息要求顺序使用连接lm,n.
　　(1) 若fst(f(vi))=pm，即消息刚从源处理机出发经过第1个连接时，则存在一些k满足下式：

(1)
其中为消息的大小，且.
　　对于式(1)，至少k=δ时是成立的.如果ι为所有k中的最小值，则消息ei,j可以使用连接lm,n的最早时刻为

(2)
　　(2) 若fst(f(vi))≠pm,假定消息ei,j在使用连接lm,n时刚刚经过了连接ll,m，则如果存在一些k满足下式:

(3)
对于式(3)，至少当k=δ时是成立的.如果ι为所有k中的最小值，则消息ei,j可以使用连接lm,n的最早时刻为

(4)
根据该路径上的最后一段连接，不难求出消息经过该路径到达目的处理机的最早时刻.
　　定理3.1. 在采用存储转发寻径技术,按式(1)～(4)选择连接的空闲时间空隙时，针对某个确定的路由，消息可以最早地到达目的处理机.
　　证明:在采用存储转发技术通信时，消息在经过中间结点时都必须先存储，然后再转发.按式(1)～(4)选择连接的空闲时间空隙时，消息都是最早地经过中间结点.因此，针对某个确定的路由，消息必定最早地到达目的处理机.
　　(b) 在采用虫蚀寻径技术时
　　假定消息ei,j要经过的连接顺序为la,b,lb,c,...,ly,z，很显然,fst(f(vi))=pa,fst(f(vj))=pz.对于任一连接，如lm,n，若已有δm,n个消息要求顺序使用该连接，令则在连接lm,n上已被分配的时间空隙TSm,n为

令　　　　　　　　　　　　TS=TSa,b∪TSb,c∪...∪TSy,z.
　　令TS对应着时间轴上被占用的时间空隙数为δ,为了便于问题的讨论,令
TS=［η1,ζ1］∪［η2,ζ2］∪...∪［ηζ,ζδ］,
其中［ηi,ζi］表示在该时间段至少有一个或多个消息在使用连接la,b,lb,c,...,ly,z中的一个或多个,则存在一些k满足下式,

(5)
其中k∈{0,...,δ}，ζ0=0，ηδ+1=∞.
　　可知,至少k=δ是满足不等式(5)的，假定ι为所有k中的最小值，则消息ei,j到达目的处理机的较早时刻为

(6)
　　根据式(5)和式(6),不难在所有的路由中确定一个能使消息较早地到达目的处理机的路由.
　　在采用虫蚀寻径技术时，消息是以异步流水方式到达目的处理机的，不同的连接上对应的时间空隙是不一致的，因此很难用统一的式子来选择不同连接上的空闲时间空隙以使消息最早地到达目的处理机.
　　本文约定，如有多个路由都能使消息最早(较早)地到达目的地，则选择最短路由中的任意一条.
　　如何将处理机分配给任务　一般认为,应选择使任务最早开始执行的处理机.下面给出某个任务在某个处理机上的最早开始执行时间的计算方法.
　　先定义DAT(vx,py)为任务vx从其父结点所接收的消息中最晚到达处理机py的消息到达的时间,又假定在任务vi分配给处理机pj时已有δ个任务｛vj1,vj2,...,vjδ｝要求顺序使用处理机pj，则如果存在一些k满足下式：
scnd(f(vjk+1))-max{scnd(f(vjk))+Γjk,DAT(vi,pj)｝≥Γi
(7)
其中k∈｛0,...,δ｝，scnd(f(vj0))=0，scnd(f(vjδ+1))=∞,可知,至少k=δ是满足不等式(7)的.假定ι是所有k中满足上述不等式的最小值，则任务vi在处理机pj上的最早开始执行时间为
max｛scnd(f(vjι))+Γjζ,DAT(vi,pj)｝.
(8)
　　根据式(7)和式(8)，便可从所有的处理机中选择使该任务能最早开始执行的处理机.
　　下面，根据上文提供的策略，构造一个非完全互连同构系统上的静态任务调度算法.本算法在选择参与调度的任务时，采用的是静态关键路径.
　　算法1. 调度算法
　　① 根据静态关键路径，创建任务优先级表.
　　(a) vi，计算tlevel(vi)与blevel(vi)，并确定一条静态关键路径.
　　(b) 置任务优先级表为空，取静态关键路径上的第1个结点作为当前结点vi.
　　(c) 如果vi的入度为0，则将该结点作为任务优先级表中最后一个结点插入表中，并把该结点的子结点的入度减1，转(d).如果vi入度不为0，则先对其所有的尚未进入任务优先级表的父结点vj按tlevel(vj)+Γj+ci,j的大小由大到小排序.以第1个父结点及其尚未进入任务优先级表的祖先结点为子图构成一个有向无环图，递归地创建该子图的任务优先级表，并将该子图的任务优先级表添加到要创建的任务优先级表的末尾.用类似的方法处理其余父结点构成的子图.最后再将结点vi加到任务优先级表的末尾，并把该结点的子结点的入度减1.
　　(d) 如果当前结点为最后一个结点，则任务优先级表创建完成，否则取静态关键路径上的下一个结点作为当前结点，执行(c).
　　② 根据每个处理机连接数目的高低，创建处理机优先级表.
　　③ 取任务优先级表中的第1个任务作为当前任务，执行④～⑥步，为该任务选择最早开始执行的处理机.
　　④ 将处理机优先级表中的第1个处理机作为当前处理机.
　　⑤ 如果当前任务在任务图中不是入结点，则按其父结点完成的先后顺序计算每个父结点发送给当前结点的消息到达当前处理机的最早时间.具体计算分成两种情况，若父结点也在当前处理机上执行，则消息的最早到达时间为父结点的完成时间；若父结点不在当前处理机上执行，则应按照式(1)～(4)或(5)与(6)计算消息的最早到达时间.根据所有消息到达的时间，求出最晚消息到达时间.如果当前任务在任务图中是入结点，则设其最晚消息到达时间为0.
　　⑥ 根据式(7)和式(8)计算当前任务在当前处理机上的最早开始时间.如果当前处理机为处理机优先级表中的最后一个处理机，则转⑦;否则从处理机优先级表中取下一个处理机作为当前处理机，转⑤.
　　⑦ 如果当前任务为任务优先级表中的最后一个任务，则结束;否则，取下一个任务作为当前任务，执行④～⑥步，为该任务选择最早开始执行的处理机.
　　这里，假定不同处理机之间的通信采用虫蚀寻径技术，根据以上调度算法分析一下如何将图1(a)中的DAG图调度到图1(b)中的多处理机系统上去.图1(a)中的静态关键路径为v3v6v8v10，根据算法第1步创建的任务优先级表为v3v1v6v2v5v8v4v7v9v10.根据算法第2步创建的处理机优先级表为p0p1p2p3.先调度v3，因为它是入结点，故将v3调度到p0上时便能最早地执行.类似地，v1被调度到p1上执行.在调度v6时，因为要从父结点v1接收消息e1,6，v6在p0上的最早开始时间为4.0.而v6在p1,p2,p3上的最早开始时间均为5.5，故v6被调度到处理机p0上执行.类似地，v2,v5,v8,v4被分别调度到处理机p2,p2,p0,p3上.在调度v7时，它可以被调度到处理机p0上，插到任务v3与v6之间执行，而消息e4,7可以插在e1,6之前占用连接l1,0.类似地，v9,v10被分别调度到处理机p2,p0上.最后，获得整个DAG图的调度长度为12.5，而整个DAG图的串行执行时间为24.0,调度结果如图1(c)所示.
　　现在，分析一下以上算法的复杂度.本算法的复杂度主要体现在③～⑦步，对于每个消息，都要计算从源到达|P|-1个目的处理机的最早时间；对于每个任务，都要计算该任务在每个处理机上的最早开始执行时间.在采用存储转发技术时，要计算消息在经过每个中间连接时的最早时间；在采用虫蚀寻径技术时，对于某个确定的路由，要先找出已经占用该路由中任一连接的所有消息，因为不同连接上已占用的消息可能部分相同，故可创建一棵AVL树,将不同连接上的消息按占用时间空隙的起止时间为关键字插入到该树中，然后再为要经过该路由的消息分配时间空隙.故在采用存储转发技术时，算法的复杂度为O(|P||V|2+|P||D||R||E|2)；在采用虫蚀寻径技术时，算法的复杂度为O(|P||V|2+|P||D||R||E|2log(|E|)),其中|D|为网络直径，|R|为网络中任意两个处理机之间的路由总数的最大值.
4　结束语
　　在一般情况下，任务调度是NP-完全问题.目前,仅仅在某些条件非常苛刻的情况下获得了最优解［4］.完全按照本文提供的策略去设计非完全互连同构系统上的静态任务调度算法是不难的，但是算法的复杂度可能会令人难以接受.对于如何设计一个较低复杂度，同时又能提供满意调度性能的算法，我们已在这些领域取得了一些进展，对此,我们将在以后的文章中加以介绍.
基金项目：本文研究得到国家自然科学基金和国家攀登计划项目基金资助.
作者简介：章军，1971年生，博士,主要研究领域为并行计算，并行任务调度，计算机体系结构.
　　　　　章立生，1962年生，副研究员,主要研究领域为计算机体系结构，计算机网络，并行处理.
　　　　　韩承德,1940年生，研究员,博士生导师,主要研究领域为计算机体系结构，并行处理.
作者单位：中国科学院计算技术研究所高性能计算机研究中心　北京　100080
本文通讯联系人:韩承德，北京100080,北京2704信箱25分箱
参考文献
　1　Hwang Jing-jang et al. Scheduling precedence graphs in systems with interprocessor communication times. SIAM Journal of Computing, 1989,18(2):244～257
　2　Wu Min-you et al. Hypertool: a programming aid for message－passing systems. IEEE Transactions on Parallel and Distributed Systems, 1990,1(3):330～343
　3　Yang T et al. PYRROS: static scheduling and code generation for message passing multiprocessors. In: Proceedings of the 6th ACM International Conference of Supercomputing. 1992. 428～437
　4　Hesham El－Rewini. Partitioning and scheduling. In: Albert Y H Zomaya ed. Parallel Distributed Computing Handbook. McGraw Hill, Inc., 1996. 239～302
　5　Hesham El－Rewini et al. Scheduling parallel program tasks onto arbitrary target machines. Journal of Parallel and Distributed Computing, 1990,9(2):138～153
　6　Kwok Yu－Kwong et al. Bubble scheduling: a quasi dynamic algorithm for static allocation of tasks to parallel architectures. In: Proceedings of the SPDP'95. Available from: http://www.cs.ust.hk
本文1998-08-28收到原稿,1998-11-30收到修改稿
