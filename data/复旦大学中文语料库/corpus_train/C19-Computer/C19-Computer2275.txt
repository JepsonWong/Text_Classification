计算机应用研究
APPLICATION RESEARCH OF COMPUTERS
2000　Vol.17　No.5　P.62-64



用Java语言开发专家系统
万江平　严明　杨建梅
摘  要  介绍用Java语言实现的一个基于产生式规则的小型专家系统。其产生式规则采用简化的M.1格式，给出了知识表示和主要数据结构及链表的实现方法，详细说明了正向推理的运行过程，并讨论了反向推理的实现。最后提出了用专家系统实现主动性服务的应用思路。
关键词  产生式  Java  反向推理   正向推理  主动服务
1  前言
　　专家系统是人工智能发展的高级阶段的产物，是人工智能领域中取得的最好成果之一。将专家的知识和经验总结成规则，以适当的形式存入计算机系统，建立知识库，然后对输入的原始数据选用合适的规则进行推理，作出判断和决策，去解决那些需要专家决定的复杂问题。专家系统已用于工业、农业、医学、地质、气象预报、军事及教育等方面。
　　Feigenbaum指出：启发式(方法和规则)是从实际经验得出的。专家系统使用启发式(Heuristic)方法和规则处理问题。能在问题空间中有效地限制搜索量的一种规则、策略、决窍、简易措施或任何方法[1]。在大多数情况下，专家系统能给出满意的问题解答。其推理机类似于抽象思维模拟，经验知识是形象思维的一种体现。
　　产生式系统中的产生式(Production)一词是从波斯特机中借用过来的，所谓波斯特机是1943年波斯特(E.Post)根据串替换规则(String Replacement Rules)提出的一种计算模型。每一条规则就称为一个产生式。每个产生式是由认识部分和行为部分所组成，因此产生式也可以看成是一个情况―行为对(Situation-Action Pair)。当给定一组事实后，我们即可用模式匹配技术去寻找适用的产生式，寻找的方法就是代入事实后能使产生式的前提成立，将这样的产生式用在这组事实上[6]。
　　本文介绍我们用Java语言实现的一个基于产生式规则的小型专家系统知识表示和推理的具体实现，并就其在主动性服务等方面的应用进行了初步的思考。
2  知识的表示
　　采用简化的M.1的知识表示方法，写出的一个去酒店所需信息的规则集如下：
R1: if  Distance &gt; 5 mile then method = bus
R2: if  Distance &gt; 1 mile and time <15 min then method="bus" R3: if Distance> 1 mile and time &gt; 15 min then method = walk
R4: if  method = bus and hotel in city then method = taxi
R5: if  method = bus and hotel in suburb then method = own car
R6: if  method = walk and weather = bad then method = jacket and  
　　walk
R7: if  method = walk and weather =good then method = no jacket
　　内部采用属性(Attribute)-值(Value)的表示方法，属性是某一事物的特性，对具体场合有与之对应的值。例如有degree为属性，yes为值。在这里，我们建立起一种适用于正向、反向两种推理方法的数据结构。
　　存储信息的数据结构如下：
事实结点：class Fact {
　　　　　　　　　　　　　String name;
　　　　　　　　　　　　　String value;
　　　　　　　　　　　}
　　其中name描述的是属性，value描述的是值。
规则结点：class Rule {
　　　　　　　　　　　　　List premise;
　　　　　　　　　　　　　Fact conclude;
　　　　　　　　　　　　　boolean Checked=false;
　　　　　　　　　　　}
　　其中premise为一个前提链表，其结点为Fact类，Conclude是该规则的结论，Checked是布尔类型，作为该规则是否被检测过的标志。
　　下面是事实链表和规则链表：
　　List Facts; (事实链表) List Rules; (规则链表)
　　List workrule; (可用规则链表，只在正向推理中有用)
　　Java语言中的对象引用实际上就是一个指针，可以编写这样的类来实现链表中的结点。
class Node
{
　　Object data;
　　Node next;  //指向下一个结点
}
　　将数据域定义成Object类是因为Object类是广义超类，任何类对象都可以给其赋值，增加了代码的通用性。为了使链表可以被访问，还需要定义一个表头，表头必须包含指向第一个结点的指针Head和指向当前结点的指针Pointer。为了便于在链表尾部增加结点，可增加一指向链表尾部的指针Tail。另外还可以用一个域来表示链表的大小，当调用者想得到链表的大小时，不必遍历整个链表。图1是这种链表的示意图。

图1链表的数据结构
3  正向推理的实现
　　使用正向推理，必须考虑到冲突消解。在这里，我们采用的消解方式是：把适用的规则以队列方式存储，选择规则时按照队列的先进先出策略，按照顺序选取。专一性顺序，即如果某一规则条件部分规定的情况比另一规则条件部分规定的情况更有针对性，则这条规则有较高的优先级。此外，若某一规则已经被检测过，那么下次将已检测过且成果的规则放在一边，不予重选。以上三种消解方式，优先级递增。
开始：do
{ //由前提链表中的事实，判断规则集中哪些适用:
　规则=规则链表头结点;
　while(规则!=null)
　{ if (该规则未被检验过)
　　　if (该规则前提可满足)
　　　　　　将该规则加入可用规则链尾部;
　　　从规则集中取下一条规则;
}
　修改标志=false;
　规则=可用规则链表头结点;
　while (规则!=null)
　{ if (该规则被检测过)
　　{取下一条规则;
　　　　　continue;
　　}
　根据取得的未被检测过的规则，得到其结果;
　将该规则置为检测过;
　if (该结果不在前提队列中)
　{将结果插入前提队列尾部;
　　　　　　修改标志置true,
　　　　　　break;
　　}
} //end of while
　//如果while循环结束且修改标志为false,
　//则所有规则都被测试过，不再有新结论
　if (修改标志= =false)
　{搜索结果 = 前提队列的最后结点;
　//最后插入前提队列尾部的是最近一次检测的结果，也就是最
　//终结果将规则集链表中所有规则的Checked标志置false;
　　　return 搜索结果;
　　}
　} while (true);
　　用户输入当前可以满足的前提组，从总规则集中寻找其前提部分可以被用户指定的前提所满足的规则，依次检测这些规则，冲突消解策略如上所述，将这些规则产生的结论并入前提组中，重新判断总规则集中有哪些新规则可以得到满足，如此循环，直到不再有新的结论被并入前提组中为止。此时，最后得到的一个结论必定是推理的结果。
　　下面是输入：distance=9 mile and weather=bad and time = 20 min时链表的状态，结果是：jacket and walk

4  反向推理的实现
　　反向推理用得较多，主要是目标明确，推理快。实现算法如下：
开始：
从Rule规则队列中寻找推出Goal结论的规则;
if (找到) {while(该规则的前提部的属性未测试完)
{//以该规则的前提部的属性作为新的Goal，递归调用推理函数;
　　if (上面的推理不成立)
　　{ return false；　//结束, 失败
　　}//只要有一个前提不成立, 那么整个结论就不成立, 取
　　//前提中的下一个属性;
　　} //while循环结束, 意味着所有前提成立, 即结论成立
　　return true;
　　}  //end of if
else{//找不到任何规则可得到此Goal向用户询问该Goal的实际值;
　　if (用户所输入的值与所需值相等)
　　　return true; 
　　else return false;
}
　　推理过程看起来就像一个搜索过程。由于对规则作了严格的规定，因此，只需考虑那些所用到的规则，也就是查找到其结论部分与所推断的事实相符合的规则即可对推理过程作出解释。
5  应用的思路
　　当今的计算机软件系统变得越来越大，它们所提供的服务(即功能、命令、操作以及资源等的总称)越来越多、越来越全。通常，用户对服务的请求是以“选择―执行”模式(或类似的模式)进行的，其中“选择”是指指定服务(无论是用名字指定，还是通过击鼠标钮激活图标来指定)，而“执行”是指服务自身的运行。这种“选择―执行”模式使得服务处于一种被动的地位，即如果用户不知道如何请求某服务的存在。则此服务也许就永远被搁置一边了。曹存根提出了主动性服务的观点，在一定条件下，即使用户未选择某一服务，服务自己也可以激活自己并运行起来 [３]。我们认为产生式专家系统可以实现“在一定条件下”的处理，尤其是当条件比较复杂的情况下效果更好。其产生式规则既可以由人工确定，更应该由系统根据其状态动态产生(如何产生，则是值得花大力气去认真研究)。这可以成为“人性化”的软件系统的基础。这是要掌握用C或C++，甚至Java实现产生式专家系统的实际意义：它是实现应用系统更智能化的一种有效手段，也是构成智能体(Agent)的基础。例如将专家系统作为一种软件构件以增加应用系统的智能。我们认为不仅是软件系统，所有的计算机应用系统中同样可以提供而且应该提供主动性服务，这既是计算机技术发展的趋势，更是市场激烈竞争的要求。
万江平(华南理工大学电子信息学院   工商管理学院  广州 510641)
严明(华南理工大学电子信息学院  工商管理学院  广州 510641)
杨建梅(华南理工大学电子信息学院  工商管理学院  广州 510641)
参考文献
1，E. A. Fergenham, The Art of Artificial Intelligent: Theme and Case Studies of Knowledge Engineering l979
2，Paul Harmon, David King, Expert System Artificial Intelligence in Business. John Wiley &amp; Sons, INC 1985
3，曹存根. 关于主动性服务的若干讨论. 软件学报, 1995, 6(11): 694~698
4，廖卫东, 陈  梅. Java程序设计实用指南. 北京: 机械工业出版社
5，陈文伟. 决策支持系统及其开发. 北京: 清华大学出版社, 1994, 10
6，路耀华.思维模拟与知识工程.北京: 清华大学出版社, 1997, 9
收稿日期：1999-12-6
